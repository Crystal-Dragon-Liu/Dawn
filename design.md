# 存储层

## 磁盘管理

**难点**：
- 如何在db读模式启动时快速收集已分配和未分配的page id信息？ 现行方案是顺序读，但显然是非常低效的(考虑bitmap？)
- .mtd文件的logging和recovery，确保元数据能在各种情况下与数据库实际情况保持一致，这有待研究。为了避免不一致导致的后果所以采用了上一个难点的现行方案，但代价是效率奇差。

**待改进**：
- 启动时收集已分配和未分配page id的信息

存储模型：行存储

页面的物理排列：所有数据都是存放在一个文件中的，依靠页面的page id得到其存储的偏移值

启动模式：创建文件启动和读文件启动，前者是在没有任何已有文件下，自行创建文件启动，后者依靠读取已有文件启动

元数据管理：DiskManager中管理以下字段：
- max_ava_pgid_：最大可获得的page id(右开)，每次free_pgid用完后都会把max_ava_pgid_翻番，然后把多出来的free id加入到free_pgid_中
- max_alloced_pgid_：最大已分配page id，用于定期检查以在尾端裁剪文件，否则id不断增大，文件大小永远不会缩小
- alloced_pgid_：存储已分配页面的集合
- free_pgid_：存储可用页面集合，每次都是分配最小的page id

读模式下，max_ava_pgid_ 可以从 .mtd 文件中读取，alloced_pgid_ 和 free_pgid_是在遍历 .db 文件时获取，遍历 .db 文件指的是扫描整个文件，查看每页的状态位，如果是已分配状态就把它加入到alloced_pgid_，否则加入free_pgid_，同时随时更新max_alloced_pgid_

# 缓冲池

难点：
- 暂无

待改进：
- frame_id的寻找和淘汰使用的是顺序搜索，效率低，因为它会访问许多不存在的帧框

和15-445实现的差不多，暂时没有什么特别的

# 索引层

# 查询执行

# 查询计划
